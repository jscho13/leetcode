INTERVIEWCAKE
------------------------------------------------------------------------
DONE: highest-product-of-3
DONE: merging-ranges
DONE: balanced-binary-tree
DONE: bst-checker -> can be refactored even a bit more... but good enough
DONE: largest-stack
DONE: queue-two-stacks
DONE: matching-parens
DONE: bracket-validator
DONE: nth-fib
DONE: cake-thief
DONE: delete-node
DONE: second-largest-item-in-bst
DONE: linked-list-cycles
DONE: rectangular love



FAILED
12. simulate-7-sided-die
4. find-duplicate-optimize-for-space
5. graph-coloring - current solution is O(N*D), find O(N+M)
5. mesh-message - bad approach
6. recursive-string-permutations
5. find-duplicate-optimize-for-space-beast-mode
6. coin
11. find-unique-among-duplicates -> needed all the hints but got it
12. shuffle.js










NOTES
Binary search:

When going through the list there's extra if/else logic for the first and last element
It's way cleaner to do a while loop.

function binarySearch() {
  // set stuff here

  while (leftIndex < rightIndex) {
    // move the leftIndex up or rightIndex down accordingly

    if (leftIndex+1 === rightIndex) {
      // you know you're at the end of the list so get out of the loop
      break;
    }
  }

  return rightIndex;
}


BST:
// Assume we have an efficient queue implementation, Queue()
// with enqueue and dequeue methods and a size property

function bfs(graph, startNode, endNode) {

  const nodesToVisit = new Queue();
  nodesToVisit.enqueue(startNode);

  // Keep track of what nodes we've already seen
  // so we don't process them twice
  const nodesAlreadySeen = new Set([startNode]);

  while (nodesToVisit.size > 0) {
    const currentNode = nodesToVisit.dequeue();

    // Stop when we reach the end node
    if (currentNode === endNode) {

      // Found it!
      break;
    }

    graph[currentNode].forEach(neighbor => {
      if (!nodesAlreadySeen.has(neighbor)) {
        nodesAlreadySeen.add(neighbor);
        nodesToVisit.enqueue(neighbor);
      }
    });
  }
}


DFS:
Space-complexity of DFS is height of the tree...
while the space-complexity of BFS is the depth of the tree... makes sense yeah?
Height of tree can be calculated via S(log n) didn't know that!


Binary:
Use right shift >>> for divide by 2 (>> appends a 1. it's good for 2's complement)
And left shift << for multiply by 2
XOR (^) is good for canceling things out



LEETCODE
------------------------------------------------------------------------
# do this in javascript
longest-univalue-path

# how are you supposed to get the key idea here?
shortest-palindrome

# solved but very slow
first-unique-character-in-a-string

# solve this manually without sort
merge-k-sorted-lists

# excellent tree practice
validate-binary-search-tree

# try and do it with DLL
lru-cache

# try without sorting
merge-intervals

# try iterative version
binary-tree-inorder-traversal

# can you solve this in one line?
maximum-depth-of-binary-tree

# do this faster
find-k-pairs-with-smallest-sums

# aim for 50%
minimum-window-substring

# solve it with a stack
shortest-unsorted-continuous-array

