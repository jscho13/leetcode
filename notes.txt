INTERVIEWCAKE
------------------------------------------------------------------------
DONE: highest-product-of-3
DONE: merging-ranges

Solutions where runtime could be optimized:
5. bst-checker - current solution is O(n^2), do one in O(n)
5. graph-coloring - current solution is O(N*D), find O(N+M)
largest-stack - the solution you did has O(n) push and pop. there's an O(1) solution
queue-two-stacks - came up with a O(n^2) solution. Find the O(n) solution
linked-list-cycles - lesson learned: a dictionary is S(n) space. The lookup is O(1), but it still takes up S(n) space.
nth-fib - O(n) and S(n). There is O(n) and S(1).
mesh-message - calculated O(n+M) incorrectly

Solutions which were optimal, but can be refactored:
bracket-validator
delete-node
recursive-string-permutations
mesh-message

Solutions you didn't get:
find-duplicate-optimize-for-space




Binary search:

When going through the list there's extra if/else logic for the first and last element
It's way cleaner to do a while loop.

function binarySearch() {
  // set stuff here

  while (leftIndex < rightIndex) {
    // move the leftIndex up or rightIndex down accordingly

    if (leftIndex+1 === rightIndex) {
      // you know you're at the end of the list so get out of the loop
      break;
    }
  }

  return rightIndex;
}


LEETCODE
------------------------------------------------------------------------
# do this in javascript
longest-univalue-path

# how are you supposed to get the key idea here?
shortest-palindrome

# solved but very slow
first-unique-character-in-a-string

# solve this manually without sort
merge-k-sorted-lists

# excellent tree practice
validate-binary-search-tree

# try and do it with DLL
lru-cache

# try without sorting
merge-intervals

# try iterative version
binary-tree-inorder-traversal

# can you solve this in one line?
maximum-depth-of-binary-tree

# do this faster
find-k-pairs-with-smallest-sums

# aim for 50%
minimum-window-substring

# solve it with a stack
shortest-unsorted-continuous-array

