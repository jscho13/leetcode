Binary search:

When going through the list there's extra if/else logic for the first and last element
It's way cleaner to do a while loop.

function binarySearch() {
  // set stuff here

  while (leftIndex < rightIndex) {
    // move the leftIndex up or rightIndex down accordingly

    if (leftIndex+1 === rightIndex) {
      // you know you're at the end of the list so get out of the loop
      break;
    }
  }

  return rightIndex;
}


# do this in javascript
longest-univalue-path

# how are you supposed to get the key idea here?
shortest-palindrome

# solved but very slow
first-unique-character-in-a-string

# solve this manually without sort
merge-k-sorted-lists

# excellent tree practice
validate-binary-search-tree

# try and do it with DLL
lru-cache

# try without sorting
merge-intervals

# try iterative version
binary-tree-inorder-traversal

# can you solve this in one line?
maximum-depth-of-binary-tree

# do this faster
find-k-pairs-with-smallest-sums

# aim for 50%
minimum-window-substring

# solve it with a stack
shortest-unsorted-continuous-array

